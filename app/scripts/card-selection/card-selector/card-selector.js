"use strict";const PROGRESS_LOAD=1,PROGRESS_SETS=2,PROGRESS_SETS_TOTAL=4,PROGRESS_CARDS=6,POTION_FACTOR=[0,2,1,0,-1];function closeWithError(e){postMessage({result:"error",message:e})}function generateCards(e,t,o){const s=[],a={};let r=0;for(set of e.sets){const t=`${set.toLowerCase().replace(" ","")}.xml`,o=`${e.appDir}/app/data/cards/${t}`,n=new marknote.Parser,c=n.parseURL(o,null,"GET");if(200===n.getXHRStatus()){const t=c.getRootElement(),o=t.getAttributeValue("name"),r=t.getChildElements();for(xmlSet of r){const t=xmlSet.getAttributeValue("version"),r=e[o+t];if(""===t||"on"===r){const e=xmlSet.getChildElements("card");for(xmlCard of e)cardData=xmlToCardData(xmlCard,o),s.push(cardData),void 0===a[cardData.cost]&&(a[cardData.cost]=0),a[cardData.cost]+=1}}}else closeWithError(`There was a problem parsing the cards for ${set}`);r+=1;const l=Math.round(r*PROGRESS_SETS_TOTAL/e.sets.length);postMessage({result:"progress",progress:PROGRESS_SETS+l-1})}postMessage({result:"progress",progress:PROGRESS_SETS+PROGRESS_SETS_TOTAL}),generateKingdom(e,t,s,a,o)}function generateKingdom(e,o,s,a,r){const n=[];let c="",l=!1,p=void 0,d=10,i=0,h=0,f=0;for(0===s.length&&closeWithError("No sets were selected");n.length<d;){let M="";const T=findTypeChances(n,s,o);let R=0;for(typeChance of T)R+=typeChance.chance;let $=e.randomness;if((void 0===$||$<.001)&&($=.001),0===s.length)closeWithError("Not enough cards are in the selected sets");else{var g=void 0,m=void 0;if(R<=Math.random()*$||Math.random()<=.001||f>=1e3)M+=`${(g=s[m=Math.floor(Math.random()*s.length)]).cardName} chosen at random`+"\n\n";else{const o=Math.random()*R;var u=void 0;let c=0,l=void 0,p=0;for(typeChance of T)void 0===u&&(p+=typeChance.chance)>=o&&(u=typeChance.cardType,c=typeChance.chance,l=typeChance.c1);if(void 0!==u){const o=[];for(E=0;E<s.length;++E){var y=s[E];for(t of y.types)if(t===u){var S={card:y,i:E};o.push(S)}}(m=Math.floor(Math.random()*o.length))>s.length-1&&(m=s.length-1);const c=(S=o[m]).card;let p=0,d=0,T=0;for(E=0;E<n.length;++E){y=n[E];let e=0;for(t1 of y.types)for(t2 of c.types)if(t1===t2){let t=!1;for(it of r)t1===it&&(t=!0);t||(e+=1)}p+=e/(Math.sqrt(y.types.length)+Math.sqrt(c.types.length)),y.cost===c.cost&&"potion"!==y.altCost&&"potion"!==c.altCost&&(d+=1),y.cost===c.cost&&"potion"===y.altCost&&"potion"===c.altCost&&(d+=2),y.cardSet===c.cardSet&&(T+=1)}let $=!0,v=Math.pow(d,2)*(Math.pow(Math.abs(c.cost-3),.5)+1);if(0===d?v-=.3:d>=3&&(v+=.2*Math.pow(d,2),d>=5&&($=!1)),p+=v/Math.pow(a[c.cost],.75)/Math.pow(n.length,.35),e.distributeSets&&e.sets.length>1){p+=Math.pow(T,2)/Math.pow(n.length,1.2)*.5}if(e.clusterPotions){var C=POTION_FACTOR[i];void 0===C&&(C=-10)}if("potion"===c.altCost?0===i?(n.length-h>=7&&($=!1),p+=.2):p-=C:C>0&&(p+=.75*C),"Event"===c.cardType||"Landmark"===c.cardType){p+=Math.pow(s.length,.02)-1}const b=[];for(y of n)for(t of y.types)t==l&&b.push(y.cardName);if(p-=Math.pow(n.length,.5)*Math.pow(R,.5)*.001,$&&p<.9*Math.random()+.4){g=c,m=S.i;const t=`'${u}' (${g.cardName})`,o=`'${l}' (${b.join(", ")})`;"all"===e.debug&&console.log(`${g.cardName} chosen : ${p.toFixed(2)}`),M+=`${t} chosen because of ${o}\n    similarity: ${p.toFixed(2)}\n\n`}else f+=1,"all"===e.debug&&($?console.log(`${c.cardName} rejected : ${p.toFixed(2)}`):console.log(`${c.cardName} rejected because invalid`))}}if(void 0!==g){let e=!1;if(l)"2"===g.cost||"3"===g.cost?"potion"!==g.altCost?"Event"!==g.cardType&&"Landmark"!==g.cardType?(p=g,l=!1,e=!0,M+=`${g.cardName} chosen as bane for Young Witch\n\n`):c+=`${g.cardName} rejected as bane due to card type\n\n`:c+=`${g.cardName} rejected as bane due to potion\n\n`:c+=`${g.cardName} rejected as bane due to cost\n\n`;else{if("Young Witch"===g.cardName){d+=1;const e=[];for(pBane of n)"2"!==pBane.cost&&"3"!==pBane.cost||"potion"!==pBane.altCost&&"Event"!==pBane.cardType&&"Landmark"!==pBane.cardType&&e.push(pBane);if(e.length>0){M+=`${(p=e[Math.floor(Math.random()*e.length)]).cardName} chosen as bane for Young Witch\n\n`}else l=!0}e=!0}"Event"!==g.cardType&&"Landmark"!==g.cardType||h>=2&&(e=!1),e&&(n.push(g),s.splice(m,1),"potion"===g.altCost&&(i+=1),"Event"!==g.cardType&&"Landmark"!==g.cardType||(d+=1,h+=1),c+=M),postMessage({result:"progress",progress:PROGRESS_CARDS+n.length-1})}}}c+=`Rejected: ${f} cards`+"\n","cards"!==e.debug&&"all"!==e.debug||console.log(c);let M=void 0,T=!1;for(g of n)"Obelisk"===g.cardName&&(T=!0);if(T){const e=[];for(g of n){const t=g.cardType.split("/");let o=!1;for(u of t)"Action"===u&&(o=!0);o&&e.push(g)}if(e.length>0){M=e[Math.floor(Math.random()*e.length)]}else for(var E=0;E<n.length;++E)"Obelisk"===n[E].cardName&&(n.splice(E,1),E=0)}let R=0;for(g of n)"Event"!==g.cardType&&"Landmark"!==g.cardType&&"Prosperity"===g.cardSet&&(R+=1);let $=!1;const v=Math.random()*n.length;if(R>=v&&($=!0),"all"===e.debug){const e=$?"Proserity cards in use":"Proserity cards not in use",t=`${R} cards`,o=`${v.toFixed(2)} chance`;console.log(`${e} with ${t} and ${o}`)}supplyCards=[],$&&(supplyCards.push("Platinum"),supplyCards.push("Colony")),result={result:"success",kingdomCards:n,supplyCards:supplyCards,baneCard:p,obeliskCard:M},postMessage(result)}function findTypeChances(e,o,a){const r=[];for(s of a){c1=s.c1,c2=s.c2;let n=0,l=0,p=0;for(c of e)for(t of c.types)c1===t&&(n+=1),c2===t&&(l+=1);for(c of o)for(t of c.types)c2===t&&(p+=1);let d=0,i=0;for(s2 of a)c1===s2.c1&&(d+=1),c2===s2.c2&&(i+=1);if(n>0&&p>0&&d>0){const e=.1*Math.pow(p,3),t=Math.pow(d,.6),o=Math.pow(i,.5),a=Math.pow(n,.3)/t/o*e/Math.pow(2,l),c=s.r+1,h={c1:c1,cardType:c2,chance:c*a};r.push(h)}}return r}self.addEventListener("message",e=>{postMessage({result:"progress",progress:0});const t=e.data;console.log(t.appDir),importScripts(`${t.appDir}/app/scripts/marknote.js`),importScripts(`${t.appDir}/app/scripts/card-selection/xml-to-card.js`),postMessage({result:"progress",progress:1});const o=new marknote.Parser,s=o.parseURL(`${t.appDir}/app/data/synergies.xml`,null,"GET");if(200===o.getXHRStatus()){const e=s.getRootElement().getChildElements("s"),o=[];for(sXml of e){const e={c1:sXml.getAttributeValue("c1"),c2:sXml.getAttributeValue("c2"),r:parseInt(sXml.getContentAt(0))};o.push(e)}const a=new marknote.Parser,r=a.parseURL(`${t.appDir}/app/data/similarignore.xml`,null,"GET");if(200===a.getXHRStatus()){const e=r.getRootElement().getChildElements("type"),s=[];for(siXml of e)s.push(siXml.getContentAt(0).toString());generateCards(t,o,s)}}else closeWithError("There was a problem parsing card synergies")});