"use strict";function AlignmentPattern(t,e,i){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=i,this.__defineGetter__("EstimatedModuleSize",function(){return this.estimatedModuleSize}),this.__defineGetter__("Count",function(){return this.count}),this.__defineGetter__("X",function(){return Math.floor(this.x)}),this.__defineGetter__("Y",function(){return Math.floor(this.y)}),this.incrementCount=function(){this.count++},this.aboutEquals=function(t,e,i){if(Math.abs(e-this.y)<=t&&Math.abs(i-this.x)<=t){const e=Math.abs(t-this.estimatedModuleSize);return e<=1||e/this.estimatedModuleSize<=1}return!1}}function AlignmentPatternFinder(t,e,i,s,n,r,o){this.image=t,this.possibleCenters=new Array,this.startX=e,this.startY=i,this.width=s,this.height=n,this.moduleSize=r,this.crossCheckStateCount=new Array(0,0,0),this.resultPointCallback=o,this.centerFromEnd=function(t,e){return e-t[2]-t[1]/2},this.foundPatternCross=function(t){const e=this.moduleSize,i=e/2;for(let s=0;s<3;s++)if(Math.abs(e-t[s])>=i)return!1;return!0},this.crossCheckVertical=function(t,e,i,s){const n=this.image,r=qrcode.height,o=this.crossCheckStateCount;o[0]=0,o[1]=0,o[2]=0;let h=t;for(;h>=0&&n[e+h*qrcode.width]&&o[1]<=i;)o[1]++,h--;if(h<0||o[1]>i)return NaN;for(;h>=0&&!n[e+h*qrcode.width]&&o[0]<=i;)o[0]++,h--;if(o[0]>i)return NaN;for(h=t+1;h<r&&n[e+h*qrcode.width]&&o[1]<=i;)o[1]++,h++;if(h==r||o[1]>i)return NaN;for(;h<r&&!n[e+h*qrcode.width]&&o[2]<=i;)o[2]++,h++;if(o[2]>i)return NaN;const u=o[0]+o[1]+o[2];return 5*Math.abs(u-s)>=2*s?NaN:this.foundPatternCross(o)?this.centerFromEnd(o,h):NaN},this.handlePossibleCenter=function(t,e,i){const s=t[0]+t[1]+t[2],n=this.centerFromEnd(t,i),r=this.crossCheckVertical(e,Math.floor(n),2*t[1],s);if(!isNaN(r)){const e=(t[0]+t[1]+t[2])/3,i=this.possibleCenters.length;for(let t=0;t<i;t++){if(this.possibleCenters[t].aboutEquals(e,r,n))return new AlignmentPattern(n,r,e)}const s=new AlignmentPattern(n,r,e);this.possibleCenters.push(s),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(s)}return null},this.find=function(){const e=this.startX,n=this.height,r=e+s,o=i+(n>>1),h=new Array(0,0,0);for(let i=0;i<n;i++){const s=o+(0==(1&i)?i+1>>1:-(i+1>>1));h[0]=0,h[1]=0,h[2]=0;let n=e;for(;n<r&&!t[n+qrcode.width*s];)n++;let l=0;for(;n<r;){if(t[n+s*qrcode.width])if(1==l)h[l]++;else if(2==l){if(this.foundPatternCross(h))if(null!=(u=this.handlePossibleCenter(h,s,n)))return u;h[0]=h[2],h[1]=1,h[2]=0,l=1}else h[++l]++;else 1==l&&l++,h[l]++;n++}var u;if(this.foundPatternCross(h))if(null!=(u=this.handlePossibleCenter(h,s,r)))return u}if(0!=this.possibleCenters.length)return this.possibleCenters[0];throw"Couldn't find enough alignment patterns"}}