"use strict";const MIN_SKIP=3,MAX_MODULES=57,INTEGER_MATH_SHIFT=8,CENTER_QUORUM=2;function FinderPattern(t,e,s){this.x=t,this.y=e,this.count=1,this.estimatedModuleSize=s,this.__defineGetter__("EstimatedModuleSize",function(){return this.estimatedModuleSize}),this.__defineGetter__("Count",function(){return this.count}),this.__defineGetter__("X",function(){return this.x}),this.__defineGetter__("Y",function(){return this.y}),this.incrementCount=function(){this.count++},this.aboutEquals=function(t,e,s){if(Math.abs(e-this.y)<=t&&Math.abs(s-this.x)<=t){const e=Math.abs(t-this.estimatedModuleSize);return e<=1||e/this.estimatedModuleSize<=1}return!1}}function FinderPatternInfo(t){this.bottomLeft=t[0],this.topLeft=t[1],this.topRight=t[2],this.__defineGetter__("BottomLeft",function(){return this.bottomLeft}),this.__defineGetter__("TopLeft",function(){return this.topLeft}),this.__defineGetter__("TopRight",function(){return this.topRight})}function FinderPatternFinder(){this.image=null,this.possibleCenters=[],this.hasSkipped=!1,this.crossCheckStateCount=new Array(0,0,0,0,0),this.resultPointCallback=null,this.__defineGetter__("CrossCheckStateCount",function(){return this.crossCheckStateCount[0]=0,this.crossCheckStateCount[1]=0,this.crossCheckStateCount[2]=0,this.crossCheckStateCount[3]=0,this.crossCheckStateCount[4]=0,this.crossCheckStateCount}),this.foundPatternCross=function(t){let e=0;for(let s=0;s<5;s++){const i=t[s];if(0==i)return!1;e+=i}if(e<7)return!1;const s=Math.floor((e<<INTEGER_MATH_SHIFT)/7),i=Math.floor(s/2);return Math.abs(s-(t[0]<<INTEGER_MATH_SHIFT))<i&&Math.abs(s-(t[1]<<INTEGER_MATH_SHIFT))<i&&Math.abs(3*s-(t[2]<<INTEGER_MATH_SHIFT))<3*i&&Math.abs(s-(t[3]<<INTEGER_MATH_SHIFT))<i&&Math.abs(s-(t[4]<<INTEGER_MATH_SHIFT))<i},this.centerFromEnd=function(t,e){return e-t[4]-t[3]-t[2]/2},this.crossCheckVertical=function(t,e,s,i){const n=this.image,r=qrcode.height,o=this.CrossCheckStateCount;let h=t;for(;h>=0&&n[e+h*qrcode.width];)o[2]++,h--;if(h<0)return NaN;for(;h>=0&&!n[e+h*qrcode.width]&&o[1]<=s;)o[1]++,h--;if(h<0||o[1]>s)return NaN;for(;h>=0&&n[e+h*qrcode.width]&&o[0]<=s;)o[0]++,h--;if(o[0]>s)return NaN;for(h=t+1;h<r&&n[e+h*qrcode.width];)o[2]++,h++;if(h==r)return NaN;for(;h<r&&!n[e+h*qrcode.width]&&o[3]<s;)o[3]++,h++;if(h==r||o[3]>=s)return NaN;for(;h<r&&n[e+h*qrcode.width]&&o[4]<s;)o[4]++,h++;if(o[4]>=s)return NaN;const a=o[0]+o[1]+o[2]+o[3]+o[4];return 5*Math.abs(a-i)>=2*i?NaN:this.foundPatternCross(o)?this.centerFromEnd(o,h):NaN},this.crossCheckHorizontal=function(t,e,s,i){const n=this.image,r=qrcode.width,o=this.CrossCheckStateCount;let h=t;for(;h>=0&&n[h+e*qrcode.width];)o[2]++,h--;if(h<0)return NaN;for(;h>=0&&!n[h+e*qrcode.width]&&o[1]<=s;)o[1]++,h--;if(h<0||o[1]>s)return NaN;for(;h>=0&&n[h+e*qrcode.width]&&o[0]<=s;)o[0]++,h--;if(o[0]>s)return NaN;for(h=t+1;h<r&&n[h+e*qrcode.width];)o[2]++,h++;if(h==r)return NaN;for(;h<r&&!n[h+e*qrcode.width]&&o[3]<s;)o[3]++,h++;if(h==r||o[3]>=s)return NaN;for(;h<r&&n[h+e*qrcode.width]&&o[4]<s;)o[4]++,h++;if(o[4]>=s)return NaN;const a=o[0]+o[1]+o[2]+o[3]+o[4];return 5*Math.abs(a-i)>=i?NaN:this.foundPatternCross(o)?this.centerFromEnd(o,h):NaN},this.handlePossibleCenter=function(t,e,s){const i=t[0]+t[1]+t[2]+t[3]+t[4];let n=this.centerFromEnd(t,s);const r=this.crossCheckVertical(e,Math.floor(n),t[2],i);if(!isNaN(r)&&(n=this.crossCheckHorizontal(Math.floor(n),Math.floor(r),t[2],i),!isNaN(n))){const t=i/7;let e=!1;const s=this.possibleCenters.length;for(let i=0;i<s;i++){const s=this.possibleCenters[i];if(s.aboutEquals(t,r,n)){s.incrementCount(),e=!0;break}}if(!e){const e=new FinderPattern(n,r,t);this.possibleCenters.push(e),null!=this.resultPointCallback&&this.resultPointCallback.foundPossibleResultPoint(e)}return!0}return!1},this.selectBestPatterns=function(){const t=this.possibleCenters.length;if(t<3)throw`Couldn't find enough finder patterns (found ${t})`;if(t>3){let s=0,i=0;for(var e=0;e<t;e++){const t=this.possibleCenters[e].EstimatedModuleSize;s+=t,i+=t*t}const n=s/t;this.possibleCenters.sort((t,e)=>{const s=Math.abs(e.EstimatedModuleSize-n),i=Math.abs(t.EstimatedModuleSize-n);return s<i?-1:s==i?0:1});const r=Math.sqrt(i/t-n*n),o=Math.max(.2*n,r);for(e=this.possibleCenters.length-1;e>=0;e--){const t=this.possibleCenters[e];Math.abs(t.EstimatedModuleSize-n)>o&&this.possibleCenters.splice(e,1)}}return this.possibleCenters.length>3&&this.possibleCenters.sort((t,e)=>t.count>e.count?-1:t.count<e.count?1:0),new Array(this.possibleCenters[0],this.possibleCenters[1],this.possibleCenters[2])},this.findRowSkip=function(){const t=this.possibleCenters.length;if(t<=1)return 0;let e=null;for(let s=0;s<t;s++){const t=this.possibleCenters[s];if(t.Count>=CENTER_QUORUM){if(null!=e)return this.hasSkipped=!0,Math.floor((Math.abs(e.X-t.X)-Math.abs(e.Y-t.Y))/2);e=t}}return 0},this.haveMultiplyConfirmedCenters=function(){let t=0,e=0;const s=this.possibleCenters.length;for(var i=0;i<s;i++){var n=this.possibleCenters[i];n.Count>=CENTER_QUORUM&&(t++,e+=n.EstimatedModuleSize)}if(t<3)return!1;const r=e/s;let o=0;for(i=0;i<s;i++)n=this.possibleCenters[i],o+=Math.abs(n.EstimatedModuleSize-r);return o<=.05*e},this.findFinderPattern=function(t){this.image=t;const e=qrcode.height,s=qrcode.width;let i=Math.floor(3*e/(4*MAX_MODULES));i<MIN_SKIP&&(i=MIN_SKIP);let n=!1;const r=new Array(5);for(let o=i-1;o<e&&!n;o+=i){r[0]=0,r[1]=0,r[2]=0,r[3]=0,r[4]=0;let e=0;for(let h=0;h<s;h++)if(t[h+o*qrcode.width])1==(1&e)&&e++,r[e]++;else if(0==(1&e))if(4==e)if(this.foundPatternCross(r)){if(this.handlePossibleCenter(r,o,h))if(i=2,this.hasSkipped)n=this.haveMultiplyConfirmedCenters();else{const t=this.findRowSkip();t>r[2]&&(o+=t-r[2]-i,h=s-1)}else{do{h++}while(h<s&&!t[h+o*qrcode.width]);h--}e=0,r[0]=0,r[1]=0,r[2]=0,r[3]=0,r[4]=0}else r[0]=r[2],r[1]=r[3],r[2]=r[4],r[3]=1,r[4]=0,e=3;else r[++e]++;else r[e]++;if(this.foundPatternCross(r))this.handlePossibleCenter(r,o,s)&&(i=r[0],this.hasSkipped&&(n=this.haveMultiplyConfirmedCenters()))}const o=this.selectBestPatterns();return qrcode.orderBestPatterns(o),new FinderPatternInfo(o)}}qrcode.orderBestPatterns=function(t){function e(t,e){const s=t.X-e.X,i=t.Y-e.Y;return Math.sqrt(s*s+i*i)}const s=e(t[0],t[1]),i=e(t[1],t[2]),n=e(t[0],t[2]);let r,o,h;if(i>=s&&i>=n?(o=t[0],r=t[1],h=t[2]):n>=i&&n>=s?(o=t[1],r=t[0],h=t[2]):(o=t[2],r=t[0],h=t[1]),function(t,e,s){const i=e.x,n=e.y;return(s.x-i)*(t.y-n)-(s.y-n)*(t.x-i)}(r,o,h)<0){const t=r;r=h,h=t}t[0]=r,t[1]=o,t[2]=h};