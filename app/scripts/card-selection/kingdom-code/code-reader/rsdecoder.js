"use strict";function ReedSolomonDecoder(e){this.field=e,this.decode=function(e,t){const i=new GF256Poly(this.field,e),r=new Array(t);for(var o=0;o<r.length;o++)r[o]=0;let l=!0;for(o=0;o<t;o++){const e=i.evaluateAt(this.field.exp(o));r[r.length-1-o]=e,0!=e&&(l=!1)}if(l)return;const n=new GF256Poly(this.field,r),s=this.runEuclideanAlgorithm(this.field.buildMonomial(t,1),n,t),f=s[0],d=s[1],h=this.findErrorLocations(f),a=this.findErrorMagnitudes(d,h,!1);for(o=0;o<h.length;o++){const t=e.length-1-this.field.log(h[o]);if(t<0)throw"ReedSolomonException Bad error location";e[t]=GF256.addOrSubtract(e[t],a[o])}},this.runEuclideanAlgorithm=function(e,t,i){if(e.Degree<t.Degree){const i=e;e=t,t=i}let r=e,o=t,l=this.field.One,n=this.field.Zero,s=this.field.Zero,f=this.field.One;for(;o.Degree>=Math.floor(i/2);){const e=r,t=l,i=s;if(l=n,s=f,(r=o).Zero)throw"r_{i-1} was zero";o=e;let d=this.field.Zero;const h=r.getCoefficient(r.Degree),a=this.field.inverse(h);for(;o.Degree>=r.Degree&&!o.Zero;){const e=o.Degree-r.Degree,t=this.field.multiply(o.getCoefficient(o.Degree),a);d=d.addOrSubtract(this.field.buildMonomial(e,t)),o=o.addOrSubtract(r.multiplyByMonomial(e,t))}n=d.multiply1(l).addOrSubtract(t),f=d.multiply1(s).addOrSubtract(i)}const d=f.getCoefficient(0);if(0==d)throw"ReedSolomonException sigmaTilde(0) was zero";const h=this.field.inverse(d),a=f.multiply2(h),c=o.multiply2(h);return new Array(a,c)},this.findErrorLocations=function(e){const t=e.Degree;if(1==t)return new Array(e.getCoefficient(1));const i=new Array(t);let r=0;for(let o=1;o<256&&r<t;o++)0==e.evaluateAt(o)&&(i[r]=this.field.inverse(o),r++);if(r!=t)throw"Error locator degree does not match number of roots";return i},this.findErrorMagnitudes=function(e,t,i){const r=t.length,o=new Array(r);for(let l=0;l<r;l++){const n=this.field.inverse(t[l]);let s=1;for(let e=0;e<r;e++)l!=e&&(s=this.field.multiply(s,GF256.addOrSubtract(1,this.field.multiply(t[e],n))));o[l]=this.field.multiply(e.evaluateAt(n),this.field.inverse(s)),i&&(o[l]=this.field.multiply(o[l],n))}return o}}